<!DOCTYPE html>
<html>
  <head>
      <meta charset="utf-8" />
      <title>script-linking-types</title>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    jax: ["input/TeX","output/HTML-CSS"],
    extensions: [],
    TeX: {
      extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
    },
    showMathMenu: false
  });
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js">
</script>
      <style>
.syntax--keyword {
  color: #c678dd;
}
.syntax--keyword.syntax--control {
  color: #c678dd;
}
.syntax--keyword.syntax--operator {
  color: #abb2bf;
}
.syntax--keyword.syntax--other.syntax--special-method {
  color: #61afef;
}
.syntax--keyword.syntax--other.syntax--unit {
  color: #d19a66;
}
.syntax--storage {
  color: #c678dd;
}
.syntax--storage.syntax--type.syntax--annotation,
.syntax--storage.syntax--type.syntax--primitive {
  color: #c678dd;
}
.syntax--storage.syntax--modifier.syntax--package,
.syntax--storage.syntax--modifier.syntax--import {
  color: #abb2bf;
}
.syntax--constant {
  color: #d19a66;
}
.syntax--constant.syntax--variable {
  color: #d19a66;
}
.syntax--constant.syntax--character.syntax--escape {
  color: #56b6c2;
}
.syntax--constant.syntax--numeric {
  color: #d19a66;
}
.syntax--constant.syntax--other.syntax--color {
  color: #56b6c2;
}
.syntax--constant.syntax--other.syntax--symbol {
  color: #56b6c2;
}
.syntax--variable {
  color: #e06c75;
}
.syntax--variable.syntax--interpolation {
  color: #be5046;
}
.syntax--variable.syntax--parameter {
  color: #abb2bf;
}
.syntax--string {
  color: #98c379;
}
.syntax--string.syntax--regexp {
  color: #56b6c2;
}
.syntax--string.syntax--regexp .syntax--source.syntax--ruby.syntax--embedded {
  color: #e5c07b;
}
.syntax--string.syntax--other.syntax--link {
  color: #e06c75;
}
.syntax--punctuation.syntax--definition.syntax--comment {
  color: #5c6370;
}
.syntax--punctuation.syntax--definition.syntax--method-parameters,
.syntax--punctuation.syntax--definition.syntax--function-parameters,
.syntax--punctuation.syntax--definition.syntax--parameters,
.syntax--punctuation.syntax--definition.syntax--separator,
.syntax--punctuation.syntax--definition.syntax--seperator,
.syntax--punctuation.syntax--definition.syntax--array {
  color: #abb2bf;
}
.syntax--punctuation.syntax--definition.syntax--heading,
.syntax--punctuation.syntax--definition.syntax--identity {
  color: #61afef;
}
.syntax--punctuation.syntax--definition.syntax--bold {
  color: #e5c07b;
  font-weight: bold;
}
.syntax--punctuation.syntax--definition.syntax--italic {
  color: #c678dd;
  font-style: italic;
}
.syntax--punctuation.syntax--section.syntax--embedded {
  color: #be5046;
}
.syntax--punctuation.syntax--section.syntax--method,
.syntax--punctuation.syntax--section.syntax--class,
.syntax--punctuation.syntax--section.syntax--inner-class {
  color: #abb2bf;
}
.syntax--support.syntax--class {
  color: #e5c07b;
}
.syntax--support.syntax--type {
  color: #56b6c2;
}
.syntax--support.syntax--function {
  color: #56b6c2;
}
.syntax--support.syntax--function.syntax--any-method {
  color: #61afef;
}
.syntax--entity.syntax--name.syntax--function {
  color: #61afef;
}
.syntax--entity.syntax--name.syntax--class,
.syntax--entity.syntax--name.syntax--type.syntax--class {
  color: #e5c07b;
}
.syntax--entity.syntax--name.syntax--section {
  color: #61afef;
}
.syntax--entity.syntax--name.syntax--tag {
  color: #e06c75;
}
.syntax--entity.syntax--other.syntax--attribute-name {
  color: #d19a66;
}
.syntax--entity.syntax--other.syntax--attribute-name.syntax--id {
  color: #61afef;
}
.syntax--meta.syntax--class {
  color: #e5c07b;
}
.syntax--meta.syntax--class.syntax--body {
  color: #abb2bf;
}
.syntax--meta.syntax--method-call,
.syntax--meta.syntax--method {
  color: #abb2bf;
}
.syntax--meta.syntax--definition.syntax--variable {
  color: #e06c75;
}
.syntax--meta.syntax--link {
  color: #d19a66;
}
.syntax--meta.syntax--require {
  color: #61afef;
}
.syntax--meta.syntax--selector {
  color: #c678dd;
}
.syntax--meta.syntax--separator {
  background-color: #373b41;
  color: #abb2bf;
}
.syntax--meta.syntax--tag {
  color: #abb2bf;
}
.syntax--underline {
  text-decoration: underline;
}
.syntax--none {
  color: #abb2bf;
}
.syntax--invalid.syntax--deprecated {
  color: #523d14 !important;
  background-color: #e0c285 !important;
}
.syntax--invalid.syntax--illegal {
  color: #ffffff !important;
  background-color: #e05252 !important;
}
.syntax--markup.syntax--bold {
  color: #d19a66;
  font-weight: bold;
}
.syntax--markup.syntax--changed {
  color: #c678dd;
}
.syntax--markup.syntax--deleted {
  color: #e06c75;
}
.syntax--markup.syntax--italic {
  color: #c678dd;
  font-style: italic;
}
.syntax--markup.syntax--heading {
  color: #e06c75;
}
.syntax--markup.syntax--heading .syntax--punctuation.syntax--definition.syntax--heading {
  color: #61afef;
}
.syntax--markup.syntax--link {
  color: #56b6c2;
}
.syntax--markup.syntax--inserted {
  color: #98c379;
}
.syntax--markup.syntax--quote {
  color: #d19a66;
}
.syntax--markup.syntax--raw {
  color: #98c379;
}
.syntax--source.syntax--c .syntax--keyword.syntax--operator {
  color: #c678dd;
}
.syntax--source.syntax--cpp .syntax--keyword.syntax--operator {
  color: #c678dd;
}
.syntax--source.syntax--cs .syntax--keyword.syntax--operator {
  color: #c678dd;
}
.syntax--source.syntax--css .syntax--property-name,
.syntax--source.syntax--css .syntax--property-value {
  color: #828997;
}
.syntax--source.syntax--css .syntax--property-name.syntax--support,
.syntax--source.syntax--css .syntax--property-value.syntax--support {
  color: #abb2bf;
}
.syntax--source.syntax--gfm .syntax--markup {
  -webkit-font-smoothing: auto;
}
.syntax--source.syntax--gfm .syntax--link .syntax--entity {
  color: #61afef;
}
.syntax--source.syntax--go .syntax--storage.syntax--type.syntax--string {
  color: #c678dd;
}
.syntax--source.syntax--ini .syntax--keyword.syntax--other.syntax--definition.syntax--ini {
  color: #e06c75;
}
.syntax--source.syntax--java .syntax--storage.syntax--modifier.syntax--import {
  color: #e5c07b;
}
.syntax--source.syntax--java .syntax--storage.syntax--type {
  color: #e5c07b;
}
.syntax--source.syntax--java .syntax--keyword.syntax--operator.syntax--instanceof {
  color: #c678dd;
}
.syntax--source.syntax--java-properties .syntax--meta.syntax--key-pair {
  color: #e06c75;
}
.syntax--source.syntax--java-properties .syntax--meta.syntax--key-pair > .syntax--punctuation {
  color: #abb2bf;
}
.syntax--source.syntax--js .syntax--keyword.syntax--operator {
  color: #56b6c2;
}
.syntax--source.syntax--js .syntax--keyword.syntax--operator.syntax--delete,
.syntax--source.syntax--js .syntax--keyword.syntax--operator.syntax--in,
.syntax--source.syntax--js .syntax--keyword.syntax--operator.syntax--of,
.syntax--source.syntax--js .syntax--keyword.syntax--operator.syntax--instanceof,
.syntax--source.syntax--js .syntax--keyword.syntax--operator.syntax--new,
.syntax--source.syntax--js .syntax--keyword.syntax--operator.syntax--typeof,
.syntax--source.syntax--js .syntax--keyword.syntax--operator.syntax--void {
  color: #c678dd;
}
.syntax--source.syntax--json .syntax--meta.syntax--structure.syntax--dictionary.syntax--json > .syntax--string.syntax--quoted.syntax--json {
  color: #e06c75;
}
.syntax--source.syntax--json .syntax--meta.syntax--structure.syntax--dictionary.syntax--json > .syntax--string.syntax--quoted.syntax--json > .syntax--punctuation.syntax--string {
  color: #e06c75;
}
.syntax--source.syntax--json .syntax--meta.syntax--structure.syntax--dictionary.syntax--json > .syntax--value.syntax--json > .syntax--string.syntax--quoted.syntax--json,
.syntax--source.syntax--json .syntax--meta.syntax--structure.syntax--array.syntax--json > .syntax--value.syntax--json > .syntax--string.syntax--quoted.syntax--json,
.syntax--source.syntax--json .syntax--meta.syntax--structure.syntax--dictionary.syntax--json > .syntax--value.syntax--json > .syntax--string.syntax--quoted.syntax--json > .syntax--punctuation,
.syntax--source.syntax--json .syntax--meta.syntax--structure.syntax--array.syntax--json > .syntax--value.syntax--json > .syntax--string.syntax--quoted.syntax--json > .syntax--punctuation {
  color: #98c379;
}
.syntax--source.syntax--json .syntax--meta.syntax--structure.syntax--dictionary.syntax--json > .syntax--constant.syntax--language.syntax--json,
.syntax--source.syntax--json .syntax--meta.syntax--structure.syntax--array.syntax--json > .syntax--constant.syntax--language.syntax--json {
  color: #56b6c2;
}
.syntax--source.syntax--ruby .syntax--constant.syntax--other.syntax--symbol > .syntax--punctuation {
  color: inherit;
}
.syntax--source.syntax--python .syntax--keyword.syntax--operator.syntax--logical.syntax--python {
  color: #c678dd;
}
.syntax--source.syntax--python .syntax--variable.syntax--parameter {
  color: #d19a66;
}
</style>
  </head>
  <body class='markdown-preview'><p>This talk is based on the paper <code>Linking Types for Multi-language Software</code> by Daniel Patterson and Amal Ahmed, which is presented at SNAPL 2017.</p>
<h3>Motivation</h3>
<p>In a large-scale software system, each part of the system is responsible for
a specific task and is, therefore, often written in a language that is best suited for that task.
This is a problem because as programmers develop complex systems, they spend much time refactoring.
(making changes to components that should result in equivalent behavior.)</p>
<p>Unfortunately, in a refactoring process programmers cannot solely rely on contextual equivalence of
their own language. Since different languages interact after they have been compiled to
a target language, programmers have to take the contexts that are inexpressible in their source language
but are expressible in the common target into account in their reasoning.</p>
<p>For example, even if a programmer is using a safe language like OCaml, the equivalence he/she relies
on in the source level can be disrupted by a C code that can be linked in a lower-level unsafe language.</p>
<p>We would like programmers to be able to reason using contextual equivalence in the language they used
even in the presence of target-level linking. A fully abstract compiler does this. If two components
are contextually equivalent at the source their compiled versions are contextually equivalent at the
target.</p>
<p>However, this comes at a steep cost: a fully abstract compiler disallow linking with components whose
behavior is inexpressible in the compiler’s source language. What if this extra behavior or control
is exactly what the programmer wants, but was not able to express in his/her source language?
Moreover, we want programmers to decide what kind of linking is necessary in his/her program, not
compiler writers.</p>
<h3>Previous Works</h3>
<p>There have been efforts to solve this problem. A cross-langauge linking is supported by Compositional
Compcert, but it only allows linking with components that satisfy CompCert’ memory model. Perconti and
Ahmed’s multi-language style of verified compilers are also a possible solution, but with a limitation
that programmers need to understand the full intermediate ST language and the compiler from R to T.</p>
<h3>Our Solution: Linking Types</h3>
<p>The proposed solution in this paper is to extend source language specifications with linking types. This is a better solution than previous works because they minimally enrich source language types
and give programmers fine-grained control by letting them annotate individual terms that need linking.</p>
<h3>Linking Types Formally</h3>
<p>To introduce linking types formally, we consider two simple source languages, <span class="math"><script type="math/tex">\lambda</script></span> and <span class="math"><script type="math/tex">\lambda^{\mathrm{ref}}</script></span>. <span class="math"><script type="math/tex">\lambda</script></span> is the simply typed lambda calculus with unit and integer base types and <span class="math"><script type="math/tex">\lambda^{\mathrm{ref}}</script></span> extends <span class="math"><script type="math/tex">\lambda</script></span> with mutable references. We want type-preserving fully abstract compilers from <span class="math"><script type="math/tex">\lambda</script></span> and <span class="math"><script type="math/tex">\lambda^{\mathrm{ref}}</script></span> to
a common target language <span class="math"><script type="math/tex">\lambda^{\mathrm{ref}}_{\mathrm{exn}}</script></span>. The target should have a rich enough type system to allow full abstract type translation and to use types to rule out equivalence disrupting linking.</p>
<p>For example, our target <span class="math"><script type="math/tex">\lambda^{\mathrm{ref}}_{\mathrm{exn}}</script></span> has a modal type system that can distinguish pure computation
from impure computation, which can be used to rule out linking <span class="math"><script type="math/tex">\lambda</script></span> with the <span class="math"><script type="math/tex">\lambda^{\mathrm{ref}}</script></span> components that use mutable references. We also add exceptions to the target to represent the extra control flow commonly found in low-level languages.</p>
<h3>Examples</h3>
<p>Let me illustrate the linking idea with two example programs <span class="math"><script type="math/tex">e_1</script></span> and <span class="math"><script type="math/tex">e_2</script></span>. These two programs are equivalent in <span class="math"><script type="math/tex">\lambda</script></span>. Since <span class="math"><script type="math/tex">\lambda</script></span> is pure, calling c once or twice produces the same result. Now consider the context <span class="math"><script type="math/tex">C^{\mathrm{ref}}</script></span> that implements a counter using a reference cell. The fully abstract
compiler would have to disallow linking with <span class="math"><script type="math/tex">{C^{\mathrm{ref}}}^+</script></span> because it can distinguish them. In other words, <span class="math"><script type="math/tex">e_1^+</script></span> and <span class="math"><script type="math/tex">e_2^+</script></span> are no longer contextually equivalent.
What if the programmer wants to link these together and is willing to give up some equivalences in order to do so?</p>
<p>To enable this linking, we present linking-types extensions, <span class="math"><script type="math/tex">\lambda^\mathrm{\kappa}</script></span> and <span class="math"><script type="math/tex">\lambda^{{\mathrm{ref}}^{\kappa}}</script></span>. The <span class="math"><script type="math/tex">\lambda^\kappa</script></span> type system includes the reference type and the computation type, <span class="math"><script type="math/tex">R^{\epsilon} \tau</script></span>, which is analogous to <span class="math"><script type="math/tex">E^{\epsilon} \tau</script></span> in the target type system. We will use <span class="math"><script type="math/tex">R^{\epsilon} \tau</script></span> to track heap effects.</p>
<p>With this extension, the programmer can annotate <span class="math"><script type="math/tex">e_1</script></span> and <span class="math"><script type="math/tex">e_2</script></span> with a linking type that specifies that the input to these programs can be heap-effecting. At this type, <span class="math"><script type="math/tex">e_1</script></span> and <span class="math"><script type="math/tex">e_2</script></span> are no longer contextually equivalent and further can be linked with <span class="math"><script type="math/tex">\lambda^{{\mathrm{ref}}^{\kappa}}</script></span>'s the counter library.</p>
<p>Without the annotation, the compiler would translate the types of <span class="math"><script type="math/tex">e_1</script></span> and <span class="math"><script type="math/tex">e_2</script></span> which is the <span class="math"><script type="math/tex">\lambda</script></span> type <strong>unit -&gt; int</strong> to the <span class="math"><script type="math/tex">\lambda^{\mathrm{ref}}_{\mathrm{exn}}</script></span> type <strong>unit -&gt; <span class="math"><script type="math/tex">E^{o}_0</script></span></strong> and the type of counter c’ which is the <span class="math"><script type="math/tex">\lambda^{\mathrm{ref}}</script></span> type <strong>unit -&gt; int</strong> to the <span class="math"><script type="math/tex">\lambda^{\mathrm{ref}}_{\mathrm{exn}}</script></span> type <strong>unit -&gt; <span class="math"><script type="math/tex">E^{\cdot}_0</script></span></strong> type. Since these types are not the same an error would be reported and linking can’t happen.</p>
<p>By contrast, <span class="math"><script type="math/tex">\lambda^\kappa</script></span>'s type <strong>unit -&gt; <span class="math"><script type="math/tex">R^{\cdot}</script></span> int -&gt; int</strong> that the programmer annotate <span class="math"><script type="math/tex">e_1</script></span> and <span class="math"><script type="math/tex">e_2</script></span>
with will be translated to <strong>(unit -&gt; <span class="math"><script type="math/tex">E^{\cdot}_O</script></span> int) -&gt; <span class="math"><script type="math/tex">E^{\cdot}_O</script></span> int</strong> which is the same from the translation of
the counter library.</p>
<p>Please note that we are not changing the programming language itself. The terms added in the extension are there only for programmer’s reasoning. (so that the programmer is aware of the contexts in which his/her programs are linked) Linking types should only allow a programmer to change equivalence of their existing language.</p>
<p>Additionally, to relate types of <span class="math"><script type="math/tex">\lambda</script></span> and <span class="math"><script type="math/tex">\lambda^{\kappa}</script></span> the linking types extension is equipped with type conversion functions <span class="math"><script type="math/tex">\kappa^+</script></span> and  <span class="math"><script type="math/tex">\kappa^-</script></span>. We will discuss this in more detail in the properties of linking types.</p>
<h3>Properties of Linking Types</h3>
<p>For any source language <span class="math"><script type="math/tex">\lambda_{src}</script></span>, an extended language <span class="math"><script type="math/tex">\lambda^{\kappa}_{src}</script></span> with type converting functions <span class="math"><script type="math/tex">\kappa^+</script></span> and <span class="math"><script type="math/tex">\kappa^-</script></span> is a linking types extension if the following properties hold:</p>
<ul>
<li><span class="math"><script type="math/tex">\forall e \in \lambda_{src}. e \in \lambda^{\kappa}_{src}</script></span></li>
<li><span class="math"><script type="math/tex">\forall \tau \in \lambda_{src}. \kappa^+ (\tau) = \tau^{\kappa}</script></span></li>
<li><span class="math"><script type="math/tex">\forall \tau^{\kappa} \in \lambda^{\kappa}_{src}. \kappa^- (\tau^{\kappa}) = \tau</script></span></li>
<li><span class="math"><script type="math/tex">\forall \tau \in \lambda_{src}. \kappa^- (\kappa^+ (\tau)) = \tau</script></span></li>
<li><span class="math"><script type="math/tex">\forall e_1, e_2 \in \lambda_{src}. e_1 \approx^{ctx}_{\lambda_{src}} e_2 : \tau \Longleftrightarrow e_1 \approx^{ctx}_{\lambda^{\kappa}_{src}} e_2 : \kappa^+ (\tau)</script></span></li>
<li>The set of programs you can write in <span class="math"><script type="math/tex">\lambda_{src}</script></span> is the same set of programs you can write in <span class="math"><script type="math/tex">\lambda^{\kappa}_{src}</script></span>.</li>
</ul></body>
</html>
